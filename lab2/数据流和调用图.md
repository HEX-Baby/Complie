# 总体结构图（类关系总览）
```
+-----------------------------+
|         FE::Parser          |   ← 顶层接口（使用者直接调用）
|-----------------------------|
| - _scanner : FE::Scanner    |
| - _parser  : FE::YaccParser |
| - ast : AST::Root*          |
|-----------------------------|
| + parseTokens()             |
| + parseAST()                |
+-----------------------------+
         ↑                ↑
         |                |
         | calls           | used by
         |                 |
+----------------+     +------------------+
|  FE::Scanner   |     |  FE::YaccParser  |
|----------------|     |------------------|
| + nextToken()  | --> | + parse()        |
+----------------+     +------------------+
         ↑
         |
         | inherits
         |
+----------------+
|  yyFlexLexer   |   ← Flex 自动生成的词法分析类
+----------------+
         ↑
         |
+----------------+
|  FlexLexer     |   ← Flex 提供的抽象接口类
+----------------+

```

# 调用流程（从输入文本到 AST）
### 以 Parser::parseAST() 为例
```
用户代码
    ↓
Parser::parseAST()
    ↓
Parser::_parser.parse()    // 调用 Bison 自动生成的解析器
    ↓
YaccParser::parse()
    ↓
YaccParser 内部循环：
    ├─ 调用 FE::Scanner::nextToken()
    │     ↓
    │   yyFlexLexer::yylex()   // Flex 状态机匹配输入
    │     ↓
    │   读取输入流中的字符
    │   识别词法单元（token）
    │   返回 YaccParser::symbol_type（含类型和值）
    │
    └─ 根据 grammar 规则进行语法分析
          ↓
       构建 AST 节点
          ↓
       语法树根节点保存到 Parser::ast
    ↓
返回 AST::Root*
```


### 以 Parser::parseTokens() 为例
```
用户代码
    ↓
Parser::parseTokens()
    ↓
循环调用 _scanner.nextToken()
    ↓
yyFlexLexer::yylex()
    ↓
词法分析器逐个识别 token：
  - 记录 token 名称
  - 提取词素 (lexeme)
  - 获取行列号
  - 保存 token 值（int/string/...）
    ↓
封装成 FE::Token
    ↓
存入 std::vector<Token>
    ↓
返回所有 tokens
```


# 数据流（Data Flow）
```
┌─────────────────────────────┐
│ 输入文件 / 输入流 (istream) │
└────────────┬────────────────┘
             │
             ▼
┌─────────────────────────────┐
│ Flex 状态机 (yyFlexLexer)   │
│  - 读取字符流                │
│  - 正则匹配 token            │
│  - 生成符号类型 + 值         │
└────────────┬────────────────┘
             │
             ▼
┌─────────────────────────────┐
│ FE::Scanner::nextToken()    │
│  - 将 yylex 结果包装为      │
│    YaccParser::symbol_type  │
│  - 提供给 Bison             │
└────────────┬────────────────┘
             │
             ▼
┌─────────────────────────────┐
│ FE::YaccParser::parse()     │
│  - 调用 nextToken 获取 token│
│  - 根据 grammar 匹配语法规则│
│  - 构造 AST 节点             │
└────────────┬────────────────┘
             │
             ▼
┌─────────────────────────────┐
│ FE::Parser::ast (AST::Root) │
│  - 保存语法树根节点          │
│  - 可供语义分析 / IR 使用    │
└─────────────────────────────┘
```

# 运行时函数调用栈示例（以 parseAST 为例）
```
main()
 └── Parser parser(&input, &output)
      └── parser.parseAST()
           └── Parser::parseAST_impl()
                └── YaccParser::parse()
                     ├── Scanner::nextToken()
                     │     └── yyFlexLexer::yylex()
                     │           └── 读取输入流字符并返回token
                     ├── 匹配 grammar
                     └── 构造 AST
                └── 返回 AST::Root*

```

| 模块                     | 数据结构 / 类型                           | 作用                     |
| ---------------------- | ----------------------------------- | ---------------------- |
| **Flex**               | `yyFlexLexer`                       | 自动生成的扫描器类，实现词法识别       |
| **FE::Scanner**        | `YaccParser::symbol_type`           | 词法单元包装对象（含 token 类型和值） |
| **FE::Parser**         | `std::vector<Token>` / `AST::Root*` | 分别保存词法分析结果或语法树         |
| **Bison (YaccParser)** | `symbol_kind` / `symbol_type`       | 枚举所有语法符号类型             |
| **AST 模块**             | `AST::Root`                         | 语法树根节点，后续供语义分析使用       |


**数据流：**
istream (输入源) → Flex (词法分析) → YaccParser (语法分析) → AST::Root (语法树)

**控制流：**
Parser 驱动 Scanner → Scanner 调用 Flex → Flex 生成 token → YaccParser 解析成 AST。